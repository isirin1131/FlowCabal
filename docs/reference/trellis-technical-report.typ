// =============================================================================
// Trellis Technical Report — Comprehensive Architecture & Design Analysis
// =============================================================================
// Author: Generated by Claude Code
// Date: 2026-02-17
// Version: 0.3.0-rc.2 (as of analysis)
// =============================================================================

#set document(
  title: "Trellis: Comprehensive Technical Report",
  author: "Claude Code Analysis",
  date: datetime(year: 2026, month: 2, day: 17),
)

#set page(
  paper: "a4",
  margin: (x: 2.2cm, y: 2.5cm),
  numbering: "1",
  header: context {
    if counter(page).get().first() > 1 [
      #set text(size: 9pt, fill: gray)
      _Trellis Technical Report_ #h(1fr) v0.3.0-rc.2
      #line(length: 100%, stroke: 0.5pt + gray)
    ]
  },
)

#set text(font: "New Computer Modern", size: 11pt)
#set heading(numbering: "1.1.")
#set par(justify: true, leading: 0.65em)

#show heading.where(level: 1): it => {
  pagebreak(weak: true)
  v(0.5em)
  text(size: 18pt, weight: "bold")[#it]
  v(0.3em)
}

#show heading.where(level: 2): it => {
  v(0.8em)
  text(size: 14pt, weight: "bold")[#it]
  v(0.2em)
}

#show heading.where(level: 3): it => {
  v(0.5em)
  text(size: 12pt, weight: "bold")[#it]
  v(0.1em)
}

#show raw.where(block: true): block.with(
  fill: luma(245),
  inset: 10pt,
  radius: 4pt,
  width: 100%,
)

// =============================================================================
// Title Page
// =============================================================================

#v(3cm)
#align(center)[
  #text(size: 36pt, weight: "bold")[Trellis]
  #v(0.3cm)
  #text(size: 16pt, fill: gray)[All-in-One AI Framework & Toolkit for\ Claude Code, Cursor, iFlow & Codex]
  #v(1.5cm)
  #text(size: 14pt)[Comprehensive Technical Report]
  #v(0.5cm)
  #text(size: 11pt, fill: gray)[
    Version 0.3.0-rc.2 \
    Published by Mindfold LLC \
    Analysis Date: February 17, 2026
  ]
  #v(2cm)
  #line(length: 60%, stroke: 1pt + gray)
  #v(0.5cm)
  #text(size: 10pt, fill: gray)[
    Package: `\@mindfoldhq/trellis` \
    Repository: `github.com/mindfold-ai/Trellis` \
    License: AGPL-3.0-only
  ]
]

#pagebreak()

// =============================================================================
// Table of Contents
// =============================================================================

#outline(
  title: [Table of Contents],
  indent: 1.5em,
  depth: 3,
)

// =============================================================================
// Chapter 1: Executive Summary
// =============================================================================

= Executive Summary

Trellis is an open-source AI-assisted development workflow framework developed by Mindfold LLC. It provides a structured approach to managing AI coding agents across multiple platforms --- specifically Claude Code, Cursor, iFlow CLI, OpenCode, and Codex --- ensuring consistent code quality, persistent session memory, and enforced development standards through a sophisticated hook-based injection system.

== Problem Statement

Modern AI coding assistants suffer from several fundamental limitations:

+ *Context Amnesia*: AI loses context between sessions, requiring developers to repeatedly explain project conventions.
+ *Specification Drift*: Instructions written in `CLAUDE.md`, `.cursorrules`, or `AGENTS.md` are frequently ignored or forgotten mid-conversation.
+ *Quality Inconsistency*: Without enforced standards, AI-generated code quality degrades as conversations grow longer.
+ *Parallel Isolation*: Running multiple AI agents simultaneously on the same codebase leads to conflicts and wasted effort.
+ *Knowledge Silos*: Team members' best practices remain in individual heads rather than being codified and shared.

== Solution Overview

Trellis addresses these challenges through five core mechanisms:

/ Auto-Injection: Required specifications and workflows are automatically injected into every AI conversation via hook scripts, not relying on AI memory.
/ Spec Library: Best practices live in auto-updated specification files organized by domain (frontend, backend, guides), growing more valuable over time.
/ Parallel Sessions: Multiple AI agents can work simultaneously in isolated Git worktrees, each with its own task context.
/ Team Synchronization: Specifications are committed to the repository, ensuring one developer's best practices benefit everyone.
/ Session Persistence: Work traces persist in journal files within the repository, enabling AI to restore project context across sessions.

== Key Metrics

#table(
  columns: (auto, auto),
  stroke: 0.5pt,
  inset: 8pt,
  [*Metric*], [*Value*],
  [Total Files in Repository], [666],
  [TypeScript Source (src/)], [5,650 lines across 50 files],
  [Python Templates], [9,395 lines across 55 files],
  [Markdown Templates], [14,400+ lines across 321 files],
  [Test Code], [3,479 lines across 20 test files],
  [Supported Platforms], [5 (Claude Code, Cursor, iFlow, OpenCode, Codex)],
  [Slash Commands], [17+],
  [Agent Definitions], [6 (implement, check, debug, research, plan, dispatch)],
  [Git Commits (as of analysis)], [205+],
  [npm Pre-release Versions], [20+ (beta.0 through rc.5)],
  [Project Age], [23 days (Jan 26 -- Feb 17, 2026)],
  [Primary Contributors], [6 (taosu, kleinhe, et al.)],
)

// =============================================================================
// Chapter 2: Architecture Overview
// =============================================================================

= Architecture Overview

Trellis follows a layered architecture with clear separation between the CLI tool (installed globally via npm), the project-local configuration (generated during `trellis init`), and the runtime hook system that operates during AI coding sessions.

== System Layers

The architecture consists of four distinct layers:

#figure(
  table(
    columns: (auto, auto, auto),
    stroke: 0.5pt,
    inset: 8pt,
    [*Layer*], [*Technology*], [*Responsibility*],
    [CLI Layer], [TypeScript / Node.js], [Installation, initialization, updates, migrations],
    [Configuration Layer], [Markdown / YAML / JSON], [Platform settings, agent definitions, slash commands],
    [Hook Layer], [Python 3.10+], [Session startup injection, subagent context, quality control loops],
    [Script Layer], [Python 3.10+], [Task management, session recording, developer identity, multi-agent orchestration],
  ),
  caption: [System layers and their technologies],
)

== Directory Structure

When Trellis is initialized in a project, it creates the following directory structure:

```
.trellis/                           # Workflow root
├── .version                        # Version tracking
├── .template-hashes.json           # Modification tracking (SHA-256)
├── .developer                      # Developer identity (gitignored)
├── .current-task                   # Current task pointer
├── .gitignore                      # Git ignore rules
├── workflow.md                     # Workflow guide (auto-injected)
├── worktree.yaml                   # Multi-agent worktree config
├── scripts/                        # Python utility scripts
│   ├── __init__.py
│   ├── common/                     # Shared utilities (10 modules)
│   ├── multi_agent/                # Parallel agent pipeline (6 modules)
│   ├── task.py                     # Task lifecycle management
│   ├── get_context.py              # Session context retrieval
│   ├── add_session.py              # Journal session recording
│   └── init_developer.py           # Developer initialization
├── workspace/                      # Per-developer workspaces
│   ├── index.md                    # Workspace index
│   └── {developer}/               # Personal workspace
│       ├── index.md               # Session history index
│       └── journal-N.md           # Numbered journal files
├── tasks/                          # Task management
│   ├── archive/                   # Archived tasks
│   └── {MM}-{DD}-{name}/         # Active task directories
│       ├── task.json              # Task metadata
│       ├── prd.md                 # Product requirements
│       ├── implement.jsonl        # Implement agent context
│       ├── check.jsonl            # Check agent context
│       └── debug.jsonl            # Debug agent context
└── spec/                           # Project guidelines
    ├── guides/                    # Thinking guides (3 docs)
    ├── backend/                   # Backend guidelines (6 docs)
    └── frontend/                  # Frontend guidelines (7 docs)

.claude/                           # Claude Code configuration
├── settings.json                  # Hook configuration
├── agents/                        # Agent definitions (6 agents)
├── commands/trellis/              # Slash commands (14 commands)
├── hooks/                         # Python hook scripts (3 hooks)
└── skills/                        # Claude skills

.cursor/                           # Cursor configuration
└── commands/                      # Slash commands (13 commands)

.iflow/                            # iFlow CLI configuration
├── settings.json                  # Hook configuration
├── agents/                        # Agent definitions
├── commands/trellis/              # Slash commands
└── hooks/                         # Python hook scripts

.opencode/                         # OpenCode configuration
├── commands/trellis/              # Slash commands
├── agents/                        # Agent definitions
├── plugin/                        # JavaScript plugins
└── lib/                           # Shared JavaScript utilities

.agents/                           # Codex skills
└── skills/                        # Skill definitions
```

== Information Flow Architecture

The runtime information flow follows a carefully orchestrated sequence:

+ *Session Start*: When a developer opens an AI coding session, the `session-start.py` hook fires, injecting workflow context, specification indices, and current task state into the conversation.

+ *Task Research*: The Research agent analyzes the codebase to identify relevant specifications and code patterns.

+ *Context Configuration*: Task-specific `.jsonl` files are populated with references to specifications that should be injected into subsequent agent calls.

+ *Agent Dispatch*: When the Dispatch agent calls subagents via the Task tool, the `inject-subagent-context.py` hook intercepts the call and dynamically injects relevant specifications, requirements (from `prd.md`), and workflow instructions into the agent's prompt.

+ *Quality Control*: When the Check agent attempts to complete, the `ralph-loop.py` hook verifies that all quality gates have been passed before allowing the agent to stop. If verification fails, the agent is forced to continue fixing issues (up to 5 iterations).

+ *Session Recording*: At the end of a session, work is recorded in journal files for future context restoration.

The key architectural insight is that *specifications are injected, not remembered*. This eliminates reliance on AI memory and ensures consistent quality across long conversations and multiple sessions.

// =============================================================================
// Chapter 3: CLI Tool Design
// =============================================================================

= CLI Tool Design

The Trellis CLI is a globally-installed Node.js tool built with TypeScript and the Commander.js framework. It provides two primary commands: `init` and `update`.

== Technology Stack

#table(
  columns: (auto, auto, auto),
  stroke: 0.5pt,
  inset: 8pt,
  [*Component*], [*Technology*], [*Purpose*],
  [CLI Framework], [Commander.js 12.x], [Command parsing and option handling],
  [Terminal UI], [Inquirer 9.x], [Interactive prompts and selections],
  [Styling], [Chalk 5.x], [Terminal color output],
  [Banner], [Figlet 1.9.x], [ASCII art banner generation],
  [Template Download], [Giget 3.x], [GitHub repository template fetching],
  [Build], [TypeScript 5.7], [Type-safe compilation to ES2022],
  [Testing], [Vitest 4.x], [Unit and integration testing],
  [Linting], [ESLint 9.x + typescript-eslint], [TypeScript code quality],
  [Python Linting], [basedpyright 1.37], [Python type checking for hooks/scripts],
  [Formatting], [Prettier 3.4], [Code formatting],
  [Git Hooks], [Husky 9.x], [Pre-commit quality enforcement],
)

== The `init` Command

The `init` command orchestrates the complete Trellis setup for a project. Its execution follows a sophisticated multi-phase process:

=== Phase 1: Environment Detection

The command begins by detecting the developer's identity and project characteristics:

- *Developer Name*: Automatically detected from `git config user.name`, or prompted interactively if not available. Can be explicitly set with `-u <name>`.
- *Project Type*: Automatically classified as `frontend`, `backend`, `fullstack`, or `unknown` by analyzing project files and dependencies.

The project type detection examines:
- *Frontend Indicators*: Presence of `vite.config.ts`, `next.config.js`, React/Vue/Svelte/Angular dependencies, `src/App.tsx`, etc.
- *Backend Indicators*: Presence of `go.mod`, `Cargo.toml`, `requirements.txt`, `pyproject.toml`, Express/Fastify/NestJS dependencies, etc.
- *Package.json Analysis*: Both `dependencies` and `devDependencies` are scanned for framework-specific packages.

=== Phase 2: Platform Selection

Developers choose which AI platforms to configure:

```bash
trellis init                          # Interactive selection
trellis init --claude --cursor        # Explicit platforms
trellis init -y                       # Defaults (Claude + Cursor)
trellis init --codex --iflow          # Alternative platforms
```

Platform selection is driven by the `AI_TOOLS` registry, which serves as the single source of truth for all platform data. Each platform entry specifies its display name, configuration directory, CLI flag, template directories, and whether it uses Python hooks.

=== Phase 3: Template Selection

The CLI fetches a template index from the Mindfold docs repository on GitHub:

```
https://raw.githubusercontent.com/mindfold-ai/docs/main/marketplace/index.json
```

Users can choose a pre-built specification template (e.g., `electron-fullstack`) or use blank templates. Three strategies handle existing specification directories:
- *Skip*: Keep existing files (default)
- *Overwrite*: Replace all files
- *Append*: Only add files that don't already exist

=== Phase 4: Structure Creation

The workflow structure is created via `createWorkflowStructure()`, which generates:
- All Python scripts (copied from template sources)
- Workspace directories for the developer
- Task management directories
- Specification templates based on project type
- Configuration files (`worktree.yaml`, `.gitignore`, `workflow.md`)

=== Phase 5: Platform Configuration

Each selected platform is configured by copying its template directory to the project. Configurators handle platform-specific concerns:

- *Claude Code*: Copies commands, agents, hooks, and `settings.json` with `{{PYTHON_CMD}}` placeholder resolution for cross-platform Python detection.
- *Cursor*: Copies commands with `trellis-` prefix (Cursor doesn't support subdirectory namespacing).
- *iFlow*: Similar to Claude Code with identical hook architecture.
- *OpenCode*: Copies commands, agents, JavaScript plugins, and library files.
- *Codex*: Writes skill definitions to `.agents/skills/` with SKILL.md format.

=== Phase 6: Post-Setup

After configuration:
+ Template hashes are computed and stored in `.template-hashes.json` for future modification tracking.
+ Developer identity is initialized via the Python `init_developer.py` script.
+ A bootstrap task (`00-bootstrap-guidelines`) is created to guide the developer through filling specification files.
+ A motivational "What We Solve" section is displayed, connecting common developer pain points to Trellis solutions.

== The `update` Command

The `update` command is the most complex component in the codebase at 1,684 lines. It performs intelligent, non-destructive updates of Trellis configuration files.

=== Version Management

The update process begins with a three-way version comparison:

+ *Project Version*: Read from `.trellis/.version` (the version installed in the project).
+ *CLI Version*: The version of the globally-installed Trellis CLI.
+ *npm Version*: The latest published version on the npm registry.

Based on comparisons:
- If CLI is newer than project: upgrade available
- If CLI is older than project: downgrade protection (requires `--allow-downgrade`)
- If CLI is older than npm: suggests CLI update

=== Hash-Based Modification Tracking

This is a key innovation. Trellis stores SHA-256 hashes of all template files at install time in `.trellis/.template-hashes.json`. During updates, the system compares:

+ *Stored Hash vs Current File*: If they match, the user hasn't modified the file --- it's safe to auto-update.
+ *Current File vs New Template*: If they differ, the template has been updated.

This creates three categories:
- *Auto-Update*: Template changed + user didn't modify = safe to replace automatically.
- *User Modified*: User modified + template changed = needs user confirmation.
- *Unchanged*: Both match = skip (already up to date).

=== Migration System

The migration system handles file organization changes between versions. Migrations are stored as JSON manifests in `src/migrations/manifests/{version}.json`:

```json
{
  "version": "0.3.0-beta.14",
  "description": "Migration description",
  "breaking": true,
  "changelog": "What changed",
  "recommendMigrate": true,
  "migrationGuide": "Detailed guide text",
  "migrations": [
    { "type": "rename", "from": "old/path.md", "to": "new/path.md" },
    { "type": "rename-dir", "from": "old/dir/", "to": "new/dir/" },
    { "type": "delete", "from": "obsolete/file.md" }
  ]
}
```

Migrations are classified into four categories:
- *Auto*: Source exists, user didn't modify, target doesn't exist --- safe to execute automatically.
- *Confirm*: Source exists, user modified it --- needs interactive confirmation.
- *Conflict*: Both source and target exist --- requires manual resolution.
- *Skip*: Source doesn't exist --- nothing to do.

The system also detects "orphaned" migrations where the source file still exists but the version suggests migration should have already occurred.

=== Backup System

Before any destructive operations, the update command creates a timestamped full backup:

```
.trellis/.backup-2026-02-17T10-30-45/
├── .trellis/                # Full trellis directory snapshot
├── .claude/                 # Full Claude config snapshot
├── .cursor/                 # Full Cursor config snapshot
└── .iflow/                  # Full iFlow config snapshot
```

User data directories (`workspace/`, `tasks/`) and previous backups are excluded from the snapshot.

=== Conflict Resolution

For user-modified files, the update command offers per-file or batch resolution:

+ *Overwrite*: Replace with new version
+ *Skip*: Keep the current version
+ *Create .new*: Save new version as `.new` file for manual merging
+ *Apply to all*: Apply the same decision to all remaining conflicts

// =============================================================================
// Chapter 4: Platform Registry & Configurator System
// =============================================================================

= Platform Registry & Configurator System

The platform system follows a plugin-like architecture where all platform-specific data and behavior is derived from a central registry.

== Single Source of Truth: `AI_TOOLS`

The `AI_TOOLS` constant in `src/types/ai-tools.ts` defines every supported platform:

```typescript
export const AI_TOOLS: Record<AITool, AIToolConfig> = {
  "claude-code": {
    name: "Claude Code",
    templateDirs: ["common", "claude"],
    configDir: ".claude",
    cliFlag: "claude",
    defaultChecked: true,
    hasPythonHooks: true,
  },
  cursor: {
    name: "Cursor",
    templateDirs: ["common", "cursor"],
    configDir: ".cursor",
    cliFlag: "cursor",
    defaultChecked: true,
    hasPythonHooks: false,
  },
  // ... opencode, iflow, codex
};
```

All derived data is computed from this registry rather than maintained separately:

- `PLATFORM_IDS`: Array of all platform identifiers
- `CONFIG_DIRS`: Array of all configuration directories (`.claude`, `.cursor`, etc.)
- `ALL_MANAGED_DIRS`: Union of `.trellis` and all config directories
- `getConfiguredPlatforms()`: Detects installed platforms by directory existence
- `getPlatformsWithPythonHooks()`: Filters platforms requiring Python (for Windows encoding)
- `resolveCliFlag()`: Maps CLI flags to platform identifiers

== Platform Functions Registry

The `PLATFORM_FUNCTIONS` object in `src/configurators/index.ts` maps each platform to its behavioral implementation:

```typescript
const PLATFORM_FUNCTIONS: Record<AITool, PlatformFunctions> = {
  "claude-code": {
    configure: configureClaude,        // Init: copy templates
    collectTemplates: () => { ... },   // Update: gather templates
  },
  cursor: {
    configure: configureCursor,
    collectTemplates: () => { ... },
  },
  // ...
};
```

This separation of data (in `AI_TOOLS`) and behavior (in `PLATFORM_FUNCTIONS`) allows adding new platforms by:

+ Adding an entry to `AI_TOOLS` (data)
+ Creating a configurator function (behavior)
+ Registering in `PLATFORM_FUNCTIONS` (wiring)
+ Creating template directories
+ Adding the CLI flag in `cli/index.ts`

== Compile-Time Safety

The codebase uses TypeScript compile-time assertions to ensure consistency:

```typescript
// Ensures every CliFlag is a valid key in InitOptions
type _AssertCliFlagsInOptions = [CliFlag] extends [keyof InitOptions]
  ? true
  : "ERROR: CliFlag has values not present in InitOptions";
const _cliFlagCheck: _AssertCliFlagsInOptions = true;
```

This means adding a new platform without updating all required locations results in a compile-time error rather than a runtime failure.

== Cross-Platform Python Detection

Platforms with Python hooks require correct Python command detection. The `shared.ts` module provides:

```typescript
function getPythonCommand(): string {
  // Try python3 first (preferred on macOS/Linux)
  // Fall back to python (common on Windows)
  // Default to python3 if neither available
}

function resolvePlaceholders(content: string): string {
  return content.replace(/\{\{PYTHON_CMD\}\}/g, getPythonCommand());
}
```

The `{{PYTHON_CMD}}` placeholder in settings files is resolved at installation time, ensuring hooks use the correct Python command for the host platform.

// =============================================================================
// Chapter 5: Hook System
// =============================================================================

= Hook System

The hook system is the runtime backbone of Trellis, implementing the core principle that "specifications are injected, not remembered." Three Python hooks intercept different lifecycle events.

== Session Start Hook (`session-start.py`)

*Trigger*: `SessionStart` event with matcher `startup`

This hook fires when an AI coding session begins. It performs the following:

+ Checks for non-interactive mode (`CLAUDE_NON_INTERACTIVE=1` or `OPENCODE_NON_INTERACTIVE=1`) and skips injection in subagent contexts.
+ Runs `get_context.py` to retrieve current session state (developer identity, git status, active tasks, current task).
+ Reads `workflow.md` for the development workflow guide.
+ Reads specification indices from `spec/frontend/index.md`, `spec/backend/index.md`, and `spec/guides/index.md`.
+ Reads the `start.md` command template for task startup instructions.
+ Returns a JSON response with `hookSpecificOutput` containing all context wrapped in XML tags:

```xml
<session-context>Session initialization context</session-context>
<current-state>Developer identity, git status, tasks</current-state>
<workflow>Full workflow guide</workflow>
<guidelines>Specification indices</guidelines>
<instructions>Task startup instructions</instructions>
<ready>Context loaded. Wait for user's first message.</ready>
```

This ensures every AI session starts with comprehensive project knowledge.

== Subagent Context Injection Hook (`inject-subagent-context.py`)

*Trigger*: `PreToolUse` event with matcher `Task` (intercepts before Task tool calls)

This is the most sophisticated hook at approximately 24,000 bytes. Its core design philosophy is: "The dispatch agent is a pure router; the hook is responsible for injecting all context."

=== Agent-Specific Context Loading

Each agent type receives tailored context:

*Implement Agent*:
+ Loads specifications from `implement.jsonl` (or falls back to `spec.jsonl`)
+ Injects the product requirements document (`prd.md`)
+ Includes implementation notes (`info.md`) if present
+ Adds workflow constraints: "Follow all specs, run lint and typecheck before finishing"

*Check Agent*:
+ Loads specifications from `check.jsonl` (or falls back to `spec.jsonl`)
+ Includes quality guidelines, cross-layer thinking guides, and finish-work checklist
+ Injects hardcoded check files: `quality-guidelines.md`, `cross-layer-thinking-guide.md`, `finish-work.md`
+ Adds workflow: "Review all code changes against specs, fix issues directly"

*Debug Agent*:
+ Loads specifications from `debug.jsonl` (or falls back to `spec.jsonl`)
+ Includes check files for context
+ Adds codex review output if available
+ Workflow: "Understand issues, fix against specs, verify fixes"

*Research Agent*:
+ Loads optional `research.jsonl`
+ Injects project structure overview
+ Workflow: "Analyze codebase, find relevant specs and patterns"

=== Context Source Files (`.jsonl`)

Each task directory can contain `.jsonl` files that define which specifications to inject:

```json
{"file": ".trellis/spec/backend/quality-guidelines.md", "reason": "Code quality standards"}
{"file": ".trellis/spec/guides/cross-layer-thinking-guide.md", "reason": "Cross-layer verification"}
{"file": "src/utils/", "type": "directory", "reason": "Utility function patterns"}
```

This mechanism allows task-specific context configuration: a frontend task injects frontend specs, while a backend task injects backend specs.

=== Phase Management

The hook automatically updates `current_phase` in `task.json` based on the subagent type being called. This enables the dispatch agent to track progress through the multi-phase workflow without manual bookkeeping.

The mapping from subagent types to actions:
- `implement` → finds phase with action "implement"
- `check` → finds phase with action "check" or "finish"
- `debug` → does not update phase (can be called at any time)
- `research` → does not update phase

== Ralph Loop Hook (`ralph-loop.py`)

*Trigger*: `SubagentStop` event with matcher `check` (intercepts when Check agent tries to stop)

Named after the "Ralph Wiggum technique" (a reference to enforcing quality like a hall monitor), this hook implements a quality control loop.

=== Verification Methods

The hook supports two verification approaches:

*Programmatic Verification*: If `worktree.yaml` defines `verify` commands, they are executed:

```yaml
verify:
  - pnpm lint
  - pnpm typecheck
```

If any command fails, the agent is blocked from stopping and receives the error output as feedback.

*Marker-Based Verification*: If no verify commands are configured, the hook reads `check.jsonl` and generates completion markers from entry reasons:

For a reason like "Ensure TypeScript typecheck passes", the marker becomes `TYPECHECK_FINISH`. The Check agent must output these markers to prove it completed each verification step.

=== Safety Mechanisms

- *Maximum Iterations*: Hard limit of 5 iterations prevents infinite loops.
- *State Timeout*: If state file is older than 30 minutes, it's automatically reset.
- *Task Change Detection*: If the current task changes, the loop state resets.
- *State Tracking*: Persistent state in `.trellis/.ralph-state.json` tracks iteration count and completion status across agent rounds.

=== Loop Control Flow

```
Check Agent attempts to stop
        ↓
ralph-loop.py intercepts
        ↓
Check verification conditions
  ├── All markers present? → Allow stop
  ├── All verify commands pass? → Allow stop
  ├── Max iterations reached? → Allow stop (with warning)
  └── Verification fails → Block stop, provide feedback
        ↓ (if blocked)
Check Agent continues working
        ↓
Attempts to stop again...
```

// =============================================================================
// Chapter 6: Agent System
// =============================================================================

= Agent System

Trellis defines six specialized agents, each with distinct responsibilities, tool access, and workflow constraints. All agents use the Opus model for maximum capability.

== Implement Agent

*Purpose*: Code implementation expert that understands specifications and requirements, then implements features.

*Tools*: Read, Write, Edit, Bash, Glob, Grep, web search, code context search

*Workflow*:
+ Read all injected specifications and requirements
+ Understand existing code patterns and architecture
+ Implement the requested changes
+ Run lint and typecheck to verify correctness

*Constraints*:
- No git commit, push, or merge operations
- Must follow injected specifications exactly
- No over-engineering beyond requirements
- Run verification before completing

== Check Agent

*Purpose*: Code quality verification expert that reviews changes against specifications and self-fixes issues.

*Tools*: Same as Implement Agent

*Workflow*:
+ Get all code changes (via `git diff`)
+ Review against injected specifications
+ Fix any issues found directly (not just report them)
+ Run verification commands
+ Output completion markers for Ralph Loop

*Key Principle*: "Fix issues yourself, don't just report them." The Check agent is expected to actively correct problems rather than passively documenting them.

*Ralph Loop Integration*: The Check agent must output specific markers (e.g., `TYPECHECK_FINISH`, `LINT_FINISH`) derived from `check.jsonl` entries to prove verification was completed.

== Debug Agent

*Purpose*: Issue fixing expert for targeted bug resolution with precise, minimal fixes.

*Tools*: Same as Implement Agent

*Workflow*:
+ Understand reported issues
+ Research if needed (search codebase, read related files)
+ Categorize by priority: P1 (critical), P2 (important), P3 (minor)
+ Fix one issue at a time, verifying each fix
+ Run typecheck after all fixes

*Guidelines*:
- DO: Make precise, minimal fixes
- DON'T: Refactor surrounding code, add features, use non-null assertions

== Research Agent

*Purpose*: Pure information gathering and documentation, without modifying any files.

*Tools*: Read, Glob, Grep, web search, code context search (no Write/Edit)

*Core Principle*: "Find and explain information" --- this agent is a documenter, not a reviewer.

*Forbidden Actions*:
- Suggesting improvements
- Criticizing code quality
- Recommending refactoring
- Modifying any files

*Output Format*: Structured research report with file paths, code patterns, and relevant specifications.

== Plan Agent

*Purpose*: Multi-agent pipeline planner that evaluates requirements and configures task directories.

*Tools*: Read, Bash, Glob, Grep, Task (can spawn sub-agents)

*Workflow*:
+ Evaluate requirements for clarity, completeness, and scope
+ Accept or reject the task (with rejection reasons)
+ Initialize context files (`implement.jsonl`, `check.jsonl`, `debug.jsonl`)
+ Spawn Research agent to analyze the codebase
+ Write `prd.md` with clear requirements and acceptance criteria
+ Configure task metadata in `task.json`
+ Validate completeness

*Rejection Criteria*: The Plan agent may reject tasks that are unclear, incomplete, out-of-scope, potentially harmful, or too large for a single implementation cycle.

== Dispatch Agent

*Purpose*: Pure orchestrator that routes work to other agents in the correct phase order.

*Tools*: Read, Bash (limited --- no file modification tools)

*Core Principle*: "Pure dispatcher" --- it never reads specifications directly. Instead, the hook system injects context into each subagent call.

*Phase Handling*:
+ Phase: implement → Call Implement Agent (30 min timeout)
+ Phase: check → Call Check Agent (15 min timeout)
+ Phase: debug → Call Debug Agent (20 min timeout, only if check fails)
+ Phase: finish → Call Check Agent with `[finish]` marker
+ Phase: create-pr → Execute `multi_agent/create_pr.py` for git commit

The Dispatch agent is the *only* agent that performs git commits, and it does so only at the final phase via a Python script rather than direct git commands.

// =============================================================================
// Chapter 7: Task Management System
// =============================================================================

= Task Management System

Tasks are the fundamental unit of work in Trellis. Each task is a directory containing metadata, requirements, and context configuration files.

== Task Lifecycle

```
Created → Planning → In Progress → Review → Completed → Archived
```

Tasks are managed through the `task.py` script, which provides a comprehensive CLI:

```bash
python3 .trellis/scripts/task.py create "Title" --slug name
python3 .trellis/scripts/task.py init-context <dir> <type>
python3 .trellis/scripts/task.py add-context <dir> implement <path> "reason"
python3 .trellis/scripts/task.py start <dir>
python3 .trellis/scripts/task.py finish
python3 .trellis/scripts/task.py archive <name>
python3 .trellis/scripts/task.py list
```

== Task Directory Structure

Each task directory contains:

#table(
  columns: (auto, auto),
  stroke: 0.5pt,
  inset: 8pt,
  [*File*], [*Purpose*],
  [`task.json`], [Metadata: title, status, priority, assignee, phases, timestamps],
  [`prd.md`], [Product requirements document with goals, criteria, technical notes],
  [`implement.jsonl`], [Context files for the Implement Agent],
  [`check.jsonl`], [Context files for the Check Agent],
  [`debug.jsonl`], [Context files for the Debug Agent],
  [`spec.jsonl`], [Fallback context for any agent (if specific file missing)],
  [`research.jsonl`], [Optional context for the Research Agent],
  [`info.md`], [Additional implementation notes (optional)],
)

== Task Metadata (`task.json`)

```json
{
  "title": "Implement user authentication",
  "description": "Add JWT-based auth to the API",
  "status": "in_progress",
  "dev_type": "backend",
  "scope": "auth",
  "priority": "P1",
  "creator": "claude-agent",
  "assignee": "claude-agent",
  "createdAt": "2026-02-17",
  "current_phase": 2,
  "next_action": [
    { "phase": 1, "action": "implement" },
    { "phase": 2, "action": "check" },
    { "phase": 3, "action": "debug" },
    { "phase": 4, "action": "finish" }
  ],
  "branch": "feat/auth",
  "worktree_path": null,
  "commit": null,
  "pr_url": null
}
```

The `next_action` array defines the multi-phase workflow. The `current_phase` field is automatically updated by the hook system as agents complete their work.

== Context Configuration (`.jsonl` files)

These files define which specifications should be injected into each agent's context:

```json
{"file": ".trellis/spec/backend/quality-guidelines.md", "reason": "Code quality"}
{"file": ".trellis/spec/backend/error-handling.md", "reason": "Error patterns"}
{"file": "src/models/user.ts", "reason": "Existing user model pattern"}
```

The hook system reads these files at runtime and injects the referenced file contents into the agent's prompt. This means specifications are loaded fresh for every agent call, eliminating context drift.

== Bootstrap Task

When Trellis is first initialized, it automatically creates a bootstrap task (`00-bootstrap-guidelines`) that guides the developer through filling specification files. This task:

- Identifies which specifications need to be filled based on project type
- Provides step-by-step instructions for documenting existing code patterns
- Includes a completion checklist
- Is set as the current task so it appears in the session start context

// =============================================================================
// Chapter 8: Specification System
// =============================================================================

= Specification System

The specification system is Trellis's knowledge management layer. It provides structured, domain-specific guidelines that are automatically injected into AI agent contexts.

== Organization

Specifications are organized into three domains:

=== Backend Guidelines (`spec/backend/`)

Six documents covering server-side development:

+ *index.md*: Entry point with guideline index
+ *directory-structure.md*: Module organization, file layout, design decisions
+ *quality-guidelines.md*: Code standards, forbidden patterns, CLI design patterns
+ *error-handling.md*: Error types, handling strategies, error propagation
+ *logging-guidelines.md*: Structured logging, log levels, what to log
+ *script-conventions.md*: Python script standards for `.trellis/scripts/`

=== Frontend Guidelines (`spec/frontend/`)

Seven documents covering client-side development:

+ *index.md*: Entry point with guideline index
+ *directory-structure.md*: Component/page/hook organization
+ *component-guidelines.md*: Component patterns, props, composition
+ *hook-guidelines.md*: Custom hooks, data fetching patterns
+ *state-management.md*: Local state, global state, server state
+ *quality-guidelines.md*: Code standards, forbidden patterns
+ *type-safety.md*: TypeScript type patterns, validation

=== Thinking Guides (`spec/guides/`)

Three documents that expand developer thinking:

+ *index.md*: Guide index with thinking triggers
+ *cross-layer-thinking-guide.md*: Data flow verification across system layers
+ *code-reuse-thinking-guide.md*: Pattern identification and duplication reduction
+ *cross-platform-thinking-guide.md*: Platform-specific assumptions and compatibility

== Design Philosophy

The specification system embodies several key principles:

/ Document Reality, Not Ideals: Guidelines should describe what the codebase *actually does*, not what developers wish it did. AI needs to match existing patterns.

/ Layered Architecture: Unlike monolithic `CLAUDE.md` or `.cursorrules` files, Trellis uses a layered approach where only relevant specifications are loaded for the current task. This reduces context overhead and improves AI focus.

/ Living Documentation: Specifications evolve with the codebase. The `/trellis:update-spec` command provides structured templates for adding new patterns, design decisions, and lessons learned.

/ Team Knowledge Capture: Because specifications are committed to the repository, one developer's hard-won insights benefit the entire team.

== Remote Spec Templates

Trellis supports downloading pre-built specification templates from the Mindfold docs repository. This allows teams to start with proven conventions for specific technology stacks (e.g., `electron-fullstack`) rather than empty templates.

The template marketplace index is fetched from:
```
https://github.com/mindfold-ai/docs/tree/main/marketplace
```

Currently, only `spec` type templates are supported, with plans for `skill`, `command`, and `full` template types.

// =============================================================================
// Chapter 9: Multi-Agent Pipeline
// =============================================================================

= Multi-Agent Pipeline

The multi-agent pipeline enables running multiple AI coding agents simultaneously on different features, each in an isolated Git worktree.

== Worktree Architecture

When `/trellis:parallel` is invoked, Trellis creates a separate Git worktree for each parallel task:

```
project/                            # Main worktree
├── .trellis/
│   └── tasks/
│       └── 02-17-feature-x/       # Task with worktree_path set
│
trellis-worktrees/                  # Worktree root (configurable)
├── feature-x/                     # Isolated worktree
│   ├── .trellis/.developer        # Copied from main
│   └── (full project checkout)    # Independent branch
└── feature-y/                     # Another isolated worktree
```

== Configuration (`worktree.yaml`)

```yaml
worktree_dir: ../trellis-worktrees  # Where to create worktrees

copy:                               # Files to copy to each worktree
  - .trellis/.developer

post_create:                        # Commands after worktree creation
  # - npm install
  # - pnpm install --frozen-lockfile

verify:                             # Quality gate commands
  # - pnpm lint
  # - pnpm typecheck
```

== Pipeline Scripts

Six Python scripts in `scripts/multi_agent/` manage the pipeline:

+ *start.py*: Creates a new worktree, sets up the branch, copies required files, runs post-create commands, and spawns an AI agent in the worktree.
+ *plan.py*: Evaluates task requirements and configures the task directory with appropriate context files.
+ *status.py*: Reports the status of all active worktree agents (running, stopped, errors).
+ *create_pr.py*: Commits changes in the worktree and creates a GitHub pull request.
+ *cleanup.py*: Removes the worktree and cleans up agent registry entries.

== Agent Registry

The `registry.py` module maintains a JSON registry of active agents:

```json
{
  "agents": [
    {
      "id": "agent-uuid",
      "worktree_path": "/path/to/worktree",
      "pid": 12345,
      "started_at": "2026-02-17T10:30:00",
      "task_dir": ".trellis/tasks/02-17-feature-x",
      "platform": "claude"
    }
  ]
}
```

This enables monitoring and managing multiple concurrent agents across different worktrees.

// =============================================================================
// Chapter 10: Session Persistence
// =============================================================================

= Session Persistence

Trellis provides a journaling system that enables AI to maintain context across sessions.

== Journal System

Each developer has a personal workspace at `.trellis/workspace/{name}/` containing:

- *index.md*: Session history table with links to journal files
- *journal-N.md*: Numbered journal files (max 2,000 lines each)

== Recording Sessions

The `/trellis:record-session` command triggers `add_session.py`, which:

+ Detects the current journal file for the developer
+ Checks if the file exceeds the 2,000-line limit
+ Creates a new numbered journal file if needed
+ Appends the session summary with timestamp, commit hash, and description
+ Updates `index.md` with the new session entry

== Context Restoration

When a new session starts, the `session-start.py` hook reads:

+ The developer's recent journal entries
+ The current task (if any)
+ Git status and recent commits

This provides AI with a summary of previous work, enabling it to resume where the last session left off without explicit re-explanation by the developer.

== Developer Identity

Multi-developer support ensures each team member has isolated workspaces:

```bash
python3 .trellis/scripts/init_developer.py john-doe
python3 .trellis/scripts/init_developer.py cursor-agent
python3 .trellis/scripts/init_developer.py claude-agent
```

Each developer gets their own journal files, and the `.developer` file is gitignored to prevent identity conflicts.

// =============================================================================
// Chapter 11: Slash Commands
// =============================================================================

= Slash Commands

Trellis provides 17+ slash commands that prepare AI for specific tasks and contexts. These commands are implemented as Markdown files that get expanded into full prompts when invoked.

== Command Categories

=== Session Management

#table(
  columns: (auto, auto),
  stroke: 0.5pt,
  inset: 8pt,
  [*Command*], [*Purpose*],
  [`/trellis:start`], [Begin a session: initialize context, read guidelines, classify task],
  [`/trellis:record-session`], [Record session summary to journal after committing],
  [`/trellis:finish-work`], [Pre-commit checklist: lint, types, tests, API changes, cross-layer],
  [`/trellis:parallel`], [Spawn parallel agents in isolated worktrees],
)

=== Development Workflow

#table(
  columns: (auto, auto),
  stroke: 0.5pt,
  inset: 8pt,
  [*Command*], [*Purpose*],
  [`/trellis:brainstorm`], [Requirements discovery for complex tasks],
  [`/trellis:before-frontend-dev`], [Load frontend guidelines before coding],
  [`/trellis:before-backend-dev`], [Load backend guidelines before coding],
  [`/trellis:break-loop`], [Deep bug analysis after debugging (5-dimension framework)],
)

=== Quality Assurance

#table(
  columns: (auto, auto),
  stroke: 0.5pt,
  inset: 8pt,
  [*Command*], [*Purpose*],
  [`/trellis:check-frontend`], [Verify code against frontend guidelines],
  [`/trellis:check-backend`], [Verify code against backend guidelines],
  [`/trellis:check-cross-layer`], [Verify data flow across system layers],
)

=== Knowledge Management

#table(
  columns: (auto, auto),
  stroke: 0.5pt,
  inset: 8pt,
  [*Command*], [*Purpose*],
  [`/trellis:update-spec`], [Capture new knowledge into specification files],
  [`/trellis:integrate-skill`], [Integrate Claude skills into project guidelines],
  [`/trellis:onboard`], [Three-part onboarding for new team members],
  [`/trellis:create-command`], [Create new custom slash commands],
  [`/trellis:improve-ut`], [Improve unit test quality and coverage],
)

== Notable Command Designs

=== Brainstorm Command

The brainstorm command implements a structured requirements discovery process:
+ Acknowledge and classify the task
+ Create a task directory immediately
+ Ask questions *one at a time* (never overwhelm with multiple questions)
+ Update the PRD after each answer
+ Propose architectural approaches for decisions
+ Confirm final requirements before proceeding

=== Break-Loop Command

After a difficult debugging session, this command triggers a 5-dimension analysis:
+ *Root Cause Category*: Missing spec, cross-layer contract, change propagation failure, test coverage gap, or implicit assumption
+ *Why Fixes Failed*: Analysis of why initial fix attempts didn't work
+ *Prevention Mechanisms*: What spec updates or checks would prevent recurrence
+ *Systematic Expansion*: Where else in the codebase might the same issue exist
+ *Knowledge Capture*: Update specifications with the learned insight

// =============================================================================
// Chapter 12: Testing Strategy
// =============================================================================

= Testing Strategy

Trellis maintains a comprehensive test suite with 20 test files covering unit tests, integration tests, and regression tests.

== Test Infrastructure

#table(
  columns: (auto, auto),
  stroke: 0.5pt,
  inset: 8pt,
  [*Aspect*], [*Configuration*],
  [Framework], [Vitest 4.x with TypeScript ESM],
  [Test Timeout], [10 seconds per test],
  [Coverage Provider], [vitest/coverage-v8],
  [Coverage Reporters], [text, html, json-summary],
  [Module System], [ES modules (ESM)],
  [CI Integration], [GitHub Actions (Node.js 20)],
)

== Testing Philosophy

The Trellis testing philosophy emphasizes:

+ *Minimal Mocking*: Only external dependencies are mocked (figlet, inquirer, child_process, fetch). Internal modules execute through their full code paths.
+ *Real File System*: Integration tests use temporary directories with actual file operations rather than mocking the filesystem.
+ *Registry Invariants*: Tests verify cross-module consistency, inspired by SQLite integrity checks.
+ *Regression Prevention*: Historical bugs are documented with verification tests that prevent recurrence.

== Test Categories

=== Unit Tests

Test individual modules in isolation:
- *Configurators*: Platform registry consistency, configured platforms detection, platform template creation
- *Types*: AI_TOOLS registry field validation, template directory inclusion
- *Templates*: Template constants non-empty, Python syntax validity, settings.json validity, command/agent/hook collections
- *Utilities*: Project detection, file writing, template hashing, version comparison, template fetching
- *Constants*: Path constants, directory names, separator conventions
- *Migrations*: Version filtering, migration summary, metadata aggregation

=== Integration Tests

Test complete command flows with real file systems:

*Init Integration (10 scenarios)*:
+ Creates expected directory structure with defaults
+ Single platform creates only that platform's files
+ Multi-platform creates all selected platform files
+ Codex platform creates `.agents/skills/` structure
+ Force mode overwrites modified files
+ Skip mode preserves modified files
+ Re-init with force produces identical file set
+ Passes developer name to initialization script
+ Writes correct version file
+ Creates spec templates for all domains

*Update Integration (11 scenarios)*:
+ Same version update is a true no-op (zero changes, no backup)
+ Dry run makes no file changes
+ Recreates deleted template files
+ Auto-updates unmodified templates
+ Force overwrites user-modified files
+ SkipAll preserves user-modified files
+ CreateNew creates `.new` copy without overwriting
+ Updates version file after successful update
+ Creates backup directory before changes
+ Downgrade protection prevents unsafe downgrades
+ AllowDowngrade permits intentional downgrades

=== Regression Tests

40+ regression tests organized by historical bug category:

*Windows/Encoding Regressions*:
- UTF-8 stdout configuration for Windows
- `CREATE_NEW_PROCESS_GROUP` flag for subprocesses
- Inline encoding fixes in entry scripts

*Path Issues*:
- Task path derivation (not under workspace)
- No hardcoded usernames in templates
- Correct path separator usage

*Semver/Migration Engine*:
- Prerelease version ordering
- Numeric identifier comparison
- Migration field completeness validation

*Template Integrity*:
- No shell scripts remaining in Python-migrated templates
- Underscore naming for multi_agent directory
- Valid JSON in settings templates
- Placeholder usage in hook commands

*Platform Registry*:
- All platforms registered with required fields
- CLI adapter supports all platforms
- Consistent configuration directory naming

== Mock Strategy

The project maintains strict mocking discipline:

#table(
  columns: (auto, auto, auto),
  stroke: 0.5pt,
  inset: 8pt,
  [*Dependency*], [*Why Mock*], [*Method*],
  [`figlet`], [ASCII banner, not testable], [`vi.mock("figlet")`],
  [`inquirer`], [Interactive prompts, no TTY in CI], [`vi.mock("inquirer")`],
  [`child_process`], [Git config, Python calls], [`vi.mock("node:child_process")`],
  [`fetch`], [npm registry network call], [`vi.stubGlobal("fetch")`],
  [`process.cwd()`], [Redirect to temp dir], [`vi.spyOn(process, "cwd")`],
  [`console.log`], [Silence test output], [`vi.spyOn(console, "log")`],
)

*Never mocked*: `fs`, `path`, internal modules (`configurators/`, `utils/`, `templates/`), `chalk`.

// =============================================================================
// Chapter 13: CI/CD Pipeline
// =============================================================================

= CI/CD Pipeline

The project uses GitHub Actions for continuous integration and deployment.

== Build Verification (`ci.yml`)

Triggered on every push to `main` and all pull requests:

+ Checkout repository
+ Setup Node.js 20 with pnpm 9
+ Install dependencies (`--frozen-lockfile`)
+ Build the project (`tsc` + template copying)
+ Verify build output (`dist/` exists with expected artifacts)

== npm Publishing (`publish.yml`)

Triggered on GitHub releases and version tags (`v*`):

+ Checkout with full git history
+ Setup Node.js 20 with npm registry configuration
+ Build the project
+ Determine npm tag based on version:
  - `beta` → `beta` tag
  - `alpha` → `alpha` tag
  - `rc` → `rc` tag
  - (other) → `latest` tag
+ Publish to npm with appropriate tag

This smart tagging ensures pre-release versions are correctly tagged on npm, preventing accidental installation of unstable versions via `npm install @mindfoldhq/trellis`.

== Pre-Commit Hooks

Husky runs `lint-staged` on every commit, which applies:
- ESLint with auto-fix on staged `.ts` files
- Prettier formatting on staged `.ts` files

This ensures code quality is maintained at the commit level, independent of CI.

// =============================================================================
// Chapter 14: Version History & Evolution
// =============================================================================

= Version History & Evolution

Trellis has evolved rapidly since its inception on January 26, 2026, with 205+ commits across 23 days.

== Version Timeline

#table(
  columns: (auto, auto, auto),
  stroke: 0.5pt,
  inset: 8pt,
  [*Version*], [*Date*], [*Key Changes*],
  [0.2.9], [Jan 26], [Initial project creation and public release],
  [0.3.0-beta.0--2], [Jan 28--29], [Template reorganization, command namespacing],
  [0.3.0-beta.3--5], [Jan 30], [Shell-to-Python migration begins, cross-platform fixes],
  [0.3.0-beta.6--9], [Jan 31], [Brainstorm enhancement, tool selection refactor],
  [0.3.0-beta.10--12], [Feb 2], [Registry refactor, data-driven approach],
  [0.3.0-beta.13--14], [Feb 3], [OpenCode support, migration manifests],
  [0.3.0-beta.15--16], [Feb 3--4], [iFlow support, Windows fixes],
  [0.3.0-rc.0--1], [Feb 6], [Release candidate, test suite, unit-test specs],
  [0.3.0-rc.2], [Feb 9], [Codex support, test strengthening],
)

== Major Evolutionary Milestones

=== Shell-to-Python Migration (beta.3--beta.5)

Originally, all scripts were implemented in Bash. This was migrated to Python 3.10+ for:
- Cross-platform compatibility (Windows has no native Bash)
- Better error handling and data parsing (JSON, YAML)
- Type safety via basedpyright
- Cleaner subprocess management

=== Platform Registry Refactor (beta.10--beta.12)

The platform system was refactored from scattered conditionals to a centralized registry:
- `AI_TOOLS` became the single source of truth
- All derived lists computed automatically
- Adding a new platform became a 5-step checklist
- Compile-time assertions prevent incomplete additions

=== Multi-Platform Expansion (beta.13--rc.2)

Rapid platform additions:
- *OpenCode* (beta.13): JavaScript plugin-based architecture
- *iFlow* (beta.15): Clone of Claude Code hook architecture
- *Codex* (rc.2): Skill-based architecture with SKILL.md format

Each addition was facilitated by the registry pattern, requiring minimal changes to core code.

=== Test Suite Addition (rc.0)

A comprehensive test suite was added with:
- Unit tests for all modules
- Integration tests for both commands
- Regression tests for all historical bugs
- Coverage tracking and CI integration
- Documented testing conventions in specifications

== Commit Patterns

The project follows Conventional Commits strictly:

```
feat(scope): description    # New features
fix(scope): description     # Bug fixes
docs(scope): description    # Documentation
refactor(scope): description # Code refactoring
test(scope): description    # Test additions
chore(scope): description   # Maintenance
```

Development velocity has been remarkably high, with the most active days seeing 30--35 commits.

// =============================================================================
// Chapter 15: Design Patterns & Principles
// =============================================================================

= Design Patterns & Principles

Several notable design patterns emerge from the Trellis codebase.

== Dogfooding

Trellis uses its own configuration to develop itself. The project contains `.trellis/`, `.claude/`, `.cursor/`, `.iflow/`, and `.opencode/` directories with active specifications and workflows. However, when initializing user projects, templates are sourced from `src/templates/` rather than the project's own configuration files, ensuring clean separation between dogfooded and distributed content.

== Single Source of Truth (SSOT)

The `AI_TOOLS` registry demonstrates SSOT:
- Platform data is defined once
- All lists, checks, and behaviors derived from it
- Adding/removing platforms requires changes in exactly one data location plus one behavior location
- Compile-time assertions catch incomplete changes

== Hash-Based Change Tracking

Instead of naive file comparison, Trellis uses SHA-256 hashes to distinguish between:
- User modifications (intentional changes to preserve)
- Template drift (Trellis updates that are safe to apply automatically)
- Unchanged files (no action needed)

This enables "smart updates" that respect user customizations while still applying framework improvements.

== Specification Injection Over Memory

The core architectural decision: rather than hoping AI remembers instructions, inject them fresh at every opportunity. This is implemented through:
- Session start hook (global context)
- Subagent context hook (task-specific context)
- Ralph loop hook (quality enforcement)

Each agent call is self-contained with all necessary context, eliminating the "AI forgot my instructions" failure mode.

== Phase-Based Orchestration

The multi-phase workflow (research → implement → check → debug → finish) is data-driven:
- Phases defined in `task.json` as an array
- Current phase tracked and auto-updated by hooks
- Dispatch agent reads phases sequentially
- Phase completion triggers advancement

This allows workflows to be customized per-task by modifying the phase array.

== Progressive Enhancement

Trellis adds capability without removing existing tools:
- Works alongside existing `CLAUDE.md`, `.cursorrules`, and `AGENTS.md` files
- Specifications layer on top of platform-native configurations
- Commands extend rather than replace platform capabilities
- Developers can use Trellis partially (e.g., only specifications without multi-agent)

// =============================================================================
// Chapter 16: Cross-Platform Considerations
// =============================================================================

= Cross-Platform Considerations

Trellis operates across macOS, Linux, and Windows, requiring careful attention to platform differences.

== Python Command Detection

Different platforms use different Python commands:
- macOS/Linux: `python3` (preferred)
- Windows: `python` (common, via Microsoft Store or installer)

The `getPythonCommand()` function probes for availability at install time, and the result is baked into `settings.json` via the `{{PYTHON_CMD}}` placeholder.

== Windows Encoding Issues

A significant portion of bug fixes address Windows-specific encoding problems:

+ *stdout UTF-8*: Python hooks explicitly reconfigure stdout/stderr to use UTF-8 encoding on Windows:
  ```python
  if sys.platform == "win32":
      sys.stdout.reconfigure(encoding="utf-8", errors="replace")
  ```

+ *Git UTF-8*: Git commands use `-c i18n.logOutputEncoding=UTF-8` for consistent output.

+ *Subprocess Creation*: Windows requires `CREATE_NEW_PROCESS_GROUP` flag for proper subprocess management in multi-agent scenarios.

== Path Handling

- All paths use forward slashes internally, even on Windows
- `pathlib.Path` is used in Python scripts for cross-platform path resolution
- Backslash normalization in `isManagedPath()` ensures Windows compatibility:
  ```typescript
  const normalized = dirPath.replace(/\\/g, "/");
  ```

// =============================================================================
// Chapter 17: Future Roadmap
// =============================================================================

= Future Roadmap

Based on the README and codebase analysis, the following features are planned:

== Confirmed Roadmap Items

+ *Better Code Review*: More thorough automated review workflow with enhanced Check agent capabilities.
+ *Skill Packs*: Pre-built workflow packs that can be installed as plugins (plug-and-play patterns for specific frameworks).
+ *Broader Tool Support*: Continued expansion to additional AI coding platforms.
+ *Stronger Session Continuity*: Automatic session-wide history saving without explicit `/trellis:record-session` invocation.
+ *Visual Parallel Sessions*: Real-time progress visualization for each parallel agent.

== Inferred from Codebase

+ *Template Marketplace Expansion*: The template fetcher supports `skill`, `command`, and `full` template types, but only `spec` is currently implemented.
+ *Enhanced Migration Guides*: The migration system supports detailed per-version guides with AI instructions, suggesting more breaking changes are anticipated.
+ *Python Type Coverage*: basedpyright integration suggests ongoing investment in Python code quality for hook scripts.

// =============================================================================
// Chapter 18: Conclusion
// =============================================================================

= Conclusion

Trellis represents a sophisticated approach to the problem of AI-assisted software development. Rather than treating AI coding assistants as stateless tools that need constant reminding, Trellis provides a framework that:

+ *Encodes knowledge structurally* through specification files that persist in the repository
+ *Enforces standards automatically* through hook-based injection at every agent interaction
+ *Enables parallel work* through Git worktree isolation with coordinated task management
+ *Preserves context* through journal-based session persistence
+ *Scales across teams* through per-developer workspaces and shared specifications

The architecture's key insight --- that specifications should be injected rather than remembered --- addresses the fundamental limitation of current AI coding assistants: context drift. By loading relevant specifications fresh at every agent call, Trellis transforms the stochastic nature of AI code generation into a more deterministic, quality-controlled process.

The rapid evolution from v0.2.9 (January 26) to v0.3.0-rc.2 (February 9) --- encompassing a shell-to-Python migration, five platform integrations, a comprehensive test suite, and a migration system --- demonstrates both the project's ambition and its architectural flexibility. The plugin-like platform registry pattern has proven particularly effective, enabling new platform support to be added in hours rather than days.

As AI coding assistants become more capable, the value of Trellis shifts from "making AI work at all" to "making AI work consistently, at scale, across teams." The specification injection pattern is platform-agnostic and could potentially be applied to future AI coding tools beyond the current five supported platforms.

#v(2cm)
#align(center)[
  #line(length: 40%, stroke: 0.5pt + gray)
  #v(0.5cm)
  #text(size: 10pt, fill: gray)[
    End of Report \
    Generated by Claude Code --- February 17, 2026 \
    Total Pages: #context { counter(page).display() }
  ]
]
